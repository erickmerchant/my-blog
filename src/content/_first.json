"Ever wanted to write your own Hot Module Replacement code, but have no idea where you'd start? This post is for you. Hot Module Replacement or HMR is one of those things that seems so magical, but I discovered a kind of clever way to do it. There are really two parts to it: a client-side part that's sort of like a IOC container, and a server-side part that uses something called Server-sent events or SSE.\n\n# Client-side part\n\nThe problem with hot module replacement for the client-side is what to do when a module changes. The server signals that a module has changed and it is reloaded, but that's not really even most of the problem. How do you update your application without throwing it all away? The answer that I came up with is to use an object to store dependencies and a single function that is called initially and then whenever a dependency changes. Here is an example.\n\n```\nimport {createApp} from './framework.js'\n\nconst app = createApp()\n\n// this is used to listen for changes\nconst eventSource = new EventSource('/changes')\n\n// what modules have what properties\nconst map = {\n  'view.js': 'view',\n  'model.js': 'model'\n}\n\n// run when something changes and initially\nconst update = (container) => {\n  app.setView(container.view)\n\n  app.setModel(container.model)\n\n  app.render()\n}\n\n// the container\nconst container = {}\n\n// when something happens\neventSource.onmessage = async (e) => {\n  const file = JSON.parse(e.data)\n\n  if (map[file] != null) {\n    container[map[file]] = await import(file)\n  \n    update(container)\n  }\n}\n\n// initial work\nfor (const [file, property] of Object.entries(map)) {\n  container[property] = await import(file)\n}\n\nupdate(container)\n```\n\nTo use that code you'd basically change the entries of map and anything that's application specific. The framework import and all the uses of `app` in the example. The key to this code is EventSource which you use to open a persistent connection to a server, allowing the server to send messages.\n\n# Server-side part\n\nNow somewhere in your server code you'd have a route that responds to requests for \"/changes\".\n\n```\nimport chokidar from 'chokidar' \nimport path from 'path'\n\nconst srcDir = path.join(process.cwd(), './src/')\n\n// listen for a get request to /changes\nserver.get('/changes', (req, res) => {\n\n  // write head as 200 with these headers\n  const headers = {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-cache',\n    // don't set if this is using http2\n    'Connection': 'keep-alive'\n  }\n\n  res.writeHead(200, headers)\n\n  // use chokidar to listen for file changes\n  chokidar\n    .watch(srcDir, {ignoreInitial: true})\n    .on('all', (type, file) => {\n      file = path.relative(srcDir, file)\n\n      // the new lines are significant here\n      res.write(`data: ${JSON.stringify(file)}\\n\\n`) \n    })\n\n  // and here\n  res.write(`\\n\\n`)\n})\n```\n\n# Some links\n\n- [Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)\n- [Dependency Injection](http://fabien.potencier.org/what-is-dependency-injection.html)\n"